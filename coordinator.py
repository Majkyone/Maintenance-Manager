from homeassistant.helpers.update_coordinator import DataUpdateCoordinator
from homeassistant.core import HomeAssistant
from homeassistant.helpers.dispatcher import async_dispatcher_send
from .const import DOMAIN, SIGNAL_TASK_STATE_CHANGED
from datetime import datetime, timedelta
import logging

_LOGGER = logging.getLogger("custom_components.my_integration")


class MaintananceCoordinator(DataUpdateCoordinator):
    def __init__(self, hass: HomeAssistant):
        super().__init__(
            hass,
            logger=_LOGGER,
            name=f"{DOMAIN}_coordinator",
            update_interval=timedelta(seconds=10),
        )
        self.notify_service = None
        self.storage = None

    async def _async_update_data(self):
        self.notify_service = self.hass.data[DOMAIN].get("mobile_app_entity_id")
        self.storage = self.hass.data[DOMAIN].get("storage")
        tasks = self.storage.get_all_tasks()
        
        for task in tasks:
            # seasonal task
            if task.reactivate is not None and datetime.fromisoformat(task.reactivate) >= datetime.now():
                continue
            # notify again
            if task.notified and task.next_notification is not None and datetime.fromisoformat(task.next_notification) <= datetime.now():
                await self.notify_user(task)
                continue
            # skip
            if task.notified:
                continue
            # interval check
            if task.type == "interval" and task.seasonal_type != "runtime":
                if datetime.fromisoformat(task.next_due) + timedelta(hours=9) <= datetime.now():
                    await self.notify_user(task)
                continue
            condition_met = False
            state_obj = self.hass.states.get(task.sensor)
            if state_obj is None:
                return
            options = ["activity", "action", "states", "turn_on", "condition"]
            value_to_check = state_obj.attributes.get(task.option) if task.option and task.option not in options else None
           
            if value_to_check in ("unknown", "unavailable", None):
                value_to_check = state_obj.state
            if task.control == "number":
                try:
                    value_to_check = float(value_to_check)
                except (ValueError, TypeError):
                    return

                if task.operator == "below" and value_to_check < task.value:
                    condition_met = True
                elif task.operator == "above" and value_to_check > task.value:
                    condition_met = True
                elif task.operator == "equal" and value_to_check == task.value:
                    condition_met = True
            else:
                if task.value == value_to_check:
                    condition_met = True
            if task.type == "interval":
                if task.duration_start == None or not condition_met:
                    task.duration_start = datetime.now().isoformat()
                if condition_met:
                    task.next_due = timedelta(seconds=task.next_due)
                    delta_interval = datetime.now() - datetime.fromisoformat(task.duration_start)
                    task.next_due -= delta_interval
                    task.next_due = task.next_due.total_seconds()
                    task.duration_start = datetime.now().isoformat()
                    
                if task.next_due > 0:
                    self.storage._async_save_task_history() # mozno nebude treba
                else:
                    await self.notify_user(task)
                continue

            if not condition_met and task.duration_condition:
                task.duration_start = None
                self.storage._async_save_task_history() # mozno nebude treba

            if condition_met:
                if task.duration_condition and not self._duration_check(task):
                    continue
                await self.notify_user(task)

    def _duration_check(self, task):
        if task.duration_start is None:
            task.duration_start = datetime.now().isoformat()
            self.storage._async_save_task_history() # mozno nebude treba
        if datetime.now() >= datetime.fromisoformat(task.duration_start) + timedelta(seconds=task.duration):
            return True
        return False
    async def notify_user(self, task):
        self.storage.async_notified_task(task.id, True, (datetime.now() + timedelta(days=1)).replace(hour=9, minute=0, second=0, microsecond=0).isoformat())
        await self.hass.services.async_call(
            "notify",
            f"mobile_app_{self.notify_service.replace('-', '_').lower()}",
            {
                "title": f"Home Maintenance: {task.name}",
                "message": f"{task.description}",
                "data": {
                    "actions": [
                        {
                            "action": "acknowledge",
                            "title": "Acknowledge"
                        },
                    ],
                    "notification_icon": "mdi:wrench",
                }
            },
        )
        await self.hass.services.async_call(
            "persistent_notification",
            "create",
            {
                "title": f"Home Maintenance: {task.name}",
                "message": f"{task.description}",
            },
        )
